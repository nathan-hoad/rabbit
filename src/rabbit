#!/usr/bin/python
'''
File rabit.py
Author: Nathan Hoad <nathan@getoffmalawn.com>
Description: Short sweet bug tracker similar(ish) to git.
Date: 30th June 2010
Version: 0.2
Updated 11th July 2010: Rewrote some stuff, reformatted output and the like. 
                        Added a detail parameter for display
Updated 13th July 2010: Tidied up code to follow style guide.
'''
import sys
import getopt
import time
import sqlite3
import os.path

_version = 0.2
_default_name = '.rabbit'

# super sweet lambda functions
prettify = lambda text, max_length: text[:max_length-3] + "..." \
    if len(text) > max_length else text
split_length = lambda text, length: [text[i:i+length] \
    for i in range(0, len(text), length)]

# Using this template ensures no fields will be missed
# TODO: Consider making this a class
NewIssue = {'type': 'unknown', 
                'status': 'new',
                'priority': 'medium',
                'summary': '',
                'date': time.strftime("%Y-%m-%d"),
                'description': ''}
                                                                               
_create_issue_statement = "create table Issue(id INTEGER PRIMARY KEY,"\
+ " type varchar(500),"\
+ " date varchar(10),"\
+ " status varchar(500),"\
+ " priority varchar(500),"\
+ " summary varchar(500),"\
+ " description varchar(5000))"

_create_comment_statement = "create table Comment("\
+ "id INTEGER PRIMARY KEY,"\
+ "issueID INTEGER,"\
+ "description varchar(500))"\

_insert_issue_statement = "insert into Issue(type, date, status, priority,"\
                        + "summary, description)"\
                        + "values('%(type)s', '%(date)s', '%(status)s', "\
                        + "'%(priority)s', '%(summary)s', '%(description)s')"

class BugTracker():
    """BugTracker class for managing bugs and comments in a project"""
    def __init__(self, filename):
        if not os.path.isfile(filename):
            self.conn = sqlite3.connect(filename)
            self.conn.execute(_create_issue_statement)
            self.conn.execute(_create_comment_statement)
            print "empty database was created in", filename
        else:
            self.conn = sqlite3.connect(filename)

    def add(self, new_issue):
        """add a new issue to the database"""
        self.conn.execute(_insert_issue_statement % new_issue)
        self.conn.commit()
        print "New issue was added"

    def _parse(self, argv):
        """Parses argv[3:] to get the fields for an issue to update or add"""
        new_issue = {}
        opts, args = getopt.getopt(sys.argv[3:], "t:s:p:d:b:", \
            ["type=", "status=", "priority=", "description=", "summary="])

        for opt, arg in opts:
            if opt in ("-t", "--type"):
                new_issue['type'] = arg
            if opt in ("-s", "--status"):
                new_issue['status'] = arg
            if opt in ("-p", "--priority"):
                new_issue['priority'] = arg
            if opt in ("-d", "--description"):
                new_issue['description'] = arg
            if opt in ("-b", "--summary"):
                new_issue['summary'] = arg

        return new_issue

    def update(self, issue_id, list):
        """modify an issue"""
        if not isinstance(issue_id, int):
            print "issue_id must be an integer! Aborting"
            return
        # TODO: add in checking to make sure the issues are valid!
        new_issue = self.parse(list)

        # this maps the new values to columns using the key name
        statement = "update Issue set " + ",\n".join(["%s = '%s'" % (k, v) 
                                for k, v in new_issue.items()]) \
                                    + " where id = %d" % issue_id

        self.conn.execute(statement)
        self.conn.commit()

    def remove(self, issue_id):
        """remove an issue by id"""
        try:
            statement = "delete from Issue where id = %d" % int(issue_id)
        except ValueError:
            print "issue_id MUST be an integer!"
            return
        self.conn.execute(statement)
        self.conn.commit()

    def print_row(self, row):
        """Print a row all nice and pretty"""
        if len(row) == 7:
            id = row[0] # fixed width, no point prettifying
            type = prettify(row[1], 7)
            date = row[2] # fixed width, no point prettifying
            status = prettify(row[3], 6)
            priority = prettify(row[4], 8)
            summary = prettify(row[5], 15)
            description = prettify(row[6], 40)
            print "| {0:2} | {1:7} | {2} | {3:6} | {4:8} | {5:15} | {6:40} |"\
            .format(id, type, date, status, priority, summary, description)
        else:
            print "| {0:2} | {1:70} |".format(row[0], prettify(row[1], 70))

    def display(self, type="issue", id=None):
        #TODO: Consider implementing ordering system or something like that
        """list all the issues or comments"""

        int_id = 0

        if id is not None:
            try:
                int_id = int(id)
            except ValueError:
                print "id MUST be an integer!"
                return

        query = "select id, type, date, status, priority, summary, description"\
              + " from Issue"
        header = "| {0:2} | {1:7} | {2:10} | {3} | {4} | {5:15} | {6:40} |"\
                    .format("id", "type", "date", "status", \
                        "priority", "summary", "description")

        if type == "comment":
            query = "select id, description from Comment where issueID = %d" \
                        % int_id
            header = "| {0:2} | {1:70} |".format("id", "description")
        if type == "detail":
            query = "select id, type, date, status, priority, summary, "\
                  + "description from Issue"\
                  + " where id = %d" % int_id
        cursor = self.conn.cursor()
        cursor.execute(query)
        nice_bars = "".join(['*' for i in range(len(header))])

        if type == "detail":
            self.print_detail(cursor.fetchone())
        else:
            print nice_bars
            print header
            print nice_bars

            if type == "issue": # display all issues
                for row in cursor:
                    self.print_row(row)
            else: # display all comments
                for row in cursor:
                    self.print_row(row)

            print nice_bars

    def print_detail(self, row):
        """Print a detailed overview of an issue"""
        #TODO: Add stuff for displaying comments here
        if row is None:
            print "Invalid row selected, nothing to display"
            return
        print "Issue ID:", row[0]
        print "Type:", row[1]
        print "Date:", row[2]
        print "Status:", row[3]
        print "Priority:", row[4]
        print "Summary:", row[5]
        print "Description:", "\n             ".join(split_length(row[6], 70)) # span description if it's too long

    def comment(self, id, comment):
        statement = "insert into Comment(issueID, description) values(%d, '%s')"\
            % (int(id), " ".join(comment))
        self.conn.execute(statement)
        self.conn.commit()

    def get_new_issue(self):
        """Process sys.argv[2:] and return a new issue in magical map form"""
        new_issue = NewIssue

        opts, args = getopt.getopt(sys.argv[2:], "t:s:p:d:b:", \
            ["type=", "status=", "priority=", "description=", "summary="])

        for opt, arg in opts:
            if arg in ("-t", "--type", "-d", "--description", "-s", "--status",\
                    "-p", "--priority", "-b", "--summary"):
                print arg, "was used as an option to", opt, "this is invalid!"
                return
            if opt in ("-t", "--type"):
                new_issue['type'] = arg
            if opt in ("-s", "--status"):
                new_issue['status'] = arg
            if opt in ("-p", "--priority"):
                new_issue['priority'] = arg
            if opt in ("-d", "--description"):
                new_issue['description'] = arg
            if opt in ("-b", "--summary"):
                new_issue['summary'] = arg
        return new_issue

def usage(specifier=None):
    """Display help and such"""
    if specifier is None:
        print "Usage:", sys.argv[0], "[COMMAND] [OPTION]..."\
            + "\nExample:", sys.argv[0], "add --summary 'Segfault on "\
            + "program start' --priority high"\
            + "\nCommands:"\
            + "\n  add         Add a new issue"\
            + "\n  list        List all issues"\
            + "\n  comment     Add a comment to an issue"\
            + "\n  remove      Remove an issue"\
            + "\n  update      Modify an issue"\
            + "\n\nPlease note that you get help at any time for the above "\
            + "commands with", sys.argv[0], "help [COMMAND]"
        return

    specifier = specifier.lower()

    if specifier == "add":
        print "Usage:", sys.argv[0], "add [OPTION]"\
            + "\nExample:", sys.argv[0], "add --summary 'Segfault on "\
            + "program start' --priority high"\
            + "\nOptions:"\
            + "\n  -d, --description=DESCRIPTION  large description of the issue"\
            + "\n  -t --type=TYPE                 problem type, e.g enhancement, bug"\
            + "\n  -s, --status=STATUS            status of the problem, e.g. fixed"\
            + "\n  -p, --priority=PRIORITY        it's priority, e.g. high or medium"\
            + "\n  -b, --summary=SUMMARY          brief overview of the issue"
    elif specifier == "rm":
        print "Usage:", sys.argv[0], "rm [ISSUEID]"
        print "Example:", sys.argv[0], "rm 1"
    elif specifier == "list":
        print "Usage:", sys.argv[0], "list [TYPE] [ID]"
        print "Example:", sys.argv[0], "list comment 5"
        print "Example:", sys.argv[0], "list detail 1"

    elif specifier == "comment":
        print "Usage:", sys.argv[0], "comment [TEXT]"
        print "Example:", sys.argv[0], "comment Can't get it to reproduce"
    elif specifier == "update":
        print "Usage:", sys.argv[0], "update [TYPE] [ISSUEID] [OPTION]..."\
            + "\nExample:", sys.argv[0], "update 1--summary 'Segfault on "\
            + "program start' --priority high"\
            + "\nOptions:"\
            + "\n  -d, --description=DESCRIPTION  large description of the issue"\
            + "\n  -t --type=TYPE                 problem type, e.g enhancement, bug"\
            + "\n  -s, --status=STATUS            status of the problem, e.g. fixed"\
            + "\n  -p, --priority=PRIORITY        it's priority, e.g. high or medium"\
            + "\n  -b, --summary=SUMMARY          brief overview of the issue"
    elif specifier == "version":
        print sys.argv[0], "version", _version
        print "rabbit, named with bugs in mind. OH THE WIT!"

def main():
    """Main method to start the program"""
    b = BugTracker(_default_name)

    if len(sys.argv) < 2:
        b.display()
        sys.exit(0)

    for opt in sys.argv[1:]:
        if opt in ("-h", "--help"):
            usage()
            sys.exit(0)
        if opt in ("-v", "--version"):
            usage("version")
            sys.exit(0)

    command = sys.argv[1].lower()

    try:
        if command == "add":
            b.add(b.get_new_issue())
        elif command == "list":
            if len(sys.argv) < 3:
                b.display()
            elif len(sys.argv) < 4:
                b.display(sys.argv[2])
            else:
                b.display(sys.argv[2], sys.argv[3])
        elif command == "update":
            b.update(sys.argv[2], sys.argv[3:])
        elif command == "rm":
            b.remove(sys.argv[2])
        elif command == "help":
            if len(sys.argv) >= 3 and sys.argv[2].lower() in ("add", "list", "update", "rm"):
                usage(sys.argv[2])
            else:
                usage()
        elif command == "comment":
            b.comment(sys.argv[2], sys.argv[3:])
        else: # displaying all issues otherwise isn't a bad idea.
            b.display()
    except IndexError:
        print "Missing or invalid arguments!"
        usage(command)

if __name__ == "__main__":
    main()
